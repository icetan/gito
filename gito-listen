#!/bin/bash
set -e

exec 0<&-

source common.sh

setrepo .

git rev-parse --is-inside-work-tree &> /dev/null || die "Not a gito repo, first run: gito init"

while test "$1"; do
  case "$1" in
    -*) die "$1 is not an option";;
  esac
done

REMOTE="$(git remote get-url origin)"
SSH_HOST="${REMOTE%%:*}"
REMOTE_FILE="${REMOTE#*:}"

grep -q : <<<"$REMOTE" && ssh_mode="ssh $SSH_HOST -- "

# XXX: This will trigger on received messages also
#autosync() {
#  ( cd "$GIT_WORK_TREE"
#    inotifywait -mrq -e "modify,delete,move" --exclude .gito . | xargs -L1 -I% gito sync
#  ) &
#}

start_push() {
  info "Pushing"
  while true; do
    #tail -f -n0 $CONSUME_FILE | $ssh_mode tee -a "$REMOTE_FILE/produce"
    tail -f -n0 "$CONSUME_FILE" | $ssh_mode "$REMOTE_FILE/bare-listen" "$REMOTE_FILE/.." || {
      warn "Push failed, rebasing"
      gito sync -f
    }
  done
}

start_pull() {
  info "Listening"
  $ssh_mode tail -f -n0 "$REMOTE_FILE/produce" | while read -r -d '' patch; do
    echo >&2 "=== START PULLING PATCH ==="
    echo >&2 "$patch"
    echo >&2 "=== END PULLING PATCH ==="

    hash=$(head -n1 <<<"$patch" | grep -oE " [a-f0-9]{40} ")

    if git rev-list --quiet -n1 $hash; then
      echo >&2 "INFO: Patch already applied, skipping"
    elif git am <<<"$patch"; then
      echo >&2 "INFO: Applied patch successfully"
    else
      git am --abort
      echo >&2 "INFO: Apply patch failed, rebasing"
      gito sync -f
    fi
  done
}

gito sync -f

trap 'trap - EXIT TERM; kill $PIDS' EXIT TERM

start_pull &
PIDS+=" $!"
#if [ "$push" ]; then
start_push &
PIDS+=" $!"
#fi

wait
